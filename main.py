import json
from flask import Flask, render_template, jsonify
import numpy as np
import clustering

# initializes the flask app
app = Flask(__name__)

@app.route("/")
def homepage():
    """"Renders the index page of the app."""
    return render_template("index.html")

@app.route("/data/<chart_id>")
def send_data(chart_id):
    """Sends the requested file."""
    with open('./data/chart-' + str(chart_id) + ".json", "r") as json_file:
        data = json.load(json_file)
    return data

@app.route("/clustering/<algorithm>/<similarity>/<label_encoding>/<chart_id>")
def cluster(algorithm, similarity, label_encoding, chart_id):
    """Returns the cluster each time series was placed in.

    Args:
        algorithm: The algorithm used for clustering. Must be "K-means"
            or "DBSCAN".
        similarity: The similarity measure used for scaling the data
            before clustering. Must be "Proximity" or "Correlation".
        label_encoding: The method used for encoding the labels. Must
            be "None" or "One-Hot".
        chart_id: The id of the file containing the data that k-means
            clustering is run on.

    Returns:
        A string of the list containing the label of the cluster each
        time series was grouped in.
    """
    with open('./data/chart-' + str(chart_id) + ".json", "r") as json_file:
        data = json.load(json_file)
    time_series_data, label_dict, ts_to_labels = clustering.time_series_array(
        data, label_encoding)
    time_series_data = clustering.preprocess(time_series_data, label_encoding,
                                             similarity, ts_to_labels)
    if algorithm == "k-means":
        labels = clustering.kmeans(time_series_data)
    else:
        labels = clustering.dbscan(time_series_data)
    return str(labels.tolist())

@app.route("/frequency/<similarity>/<label_encoding>/<chart_id>")
def frequency(similarity, label_encoding, chart_id):
    """Runs kmeans and gets the frequencies of labels per time series
    and labels per cluster.

    Args:
        similarity: The similarity measure used for scaling the data
            before clustering. Must be "proximity" or "correlation".
        label_encoding: The method used for encoding the labels. Must
            be "none" or "one-hot".
        chart_id: The id of the file containing the data that k-means
            clustering is run on.

    Returns:
        A json with a list of labels generated by running kmeans, an
        array of labels per time series and an array of labels per cluster.

    """
    with open('./data/chart-' + str(chart_id) + ".json", "r") as json_file:
        data = json.load(json_file)
    time_series_data, label_dict, ts_to_labels = clustering.time_series_array(
        data, "one-hot")
    time_series_data = clustering.preprocess(time_series_data, label_encoding,
                                             similarity, ts_to_labels)

    labels = clustering.kmeans(time_series_data)
    cluster_labels = clustering.cluster_to_labels(labels, ts_to_labels)
    system_labels = list(label_dict.keys())

    ordered = np.argsort(np.array(system_labels))
    ordered_labels = [0]*len(system_labels)
    ordered_ts_labels = np.zeros(ts_to_labels.shape)
    ordered_cluster_labels = np.zeros(cluster_labels.shape)

    for i, elt in enumerate(ordered):
        ordered_ts_labels[:, i] = ts_to_labels[:, elt]
        ordered_cluster_labels[:, i] = cluster_labels[:, elt]
        ordered_labels[i] = system_labels[elt]

    return jsonify({"labels": ordered_labels,
                    "ts_labels": ordered_ts_labels.tolist(),
                    "cluster_labels": ordered_cluster_labels.tolist()})

@app.route("/tuning/<algorithm>/<similarity>/<label_encoding>/<chart_id>")
def tune_parameters(algorithm, similarity, label_encoding, chart_id):
    """Returns a list with the results of using different parameters
    for algorithm run on the chart chart_id.

    Args:
        algorithm: The algorithm used for clustering. Must be "k-means"
            or "dbscan".
        similarity: The similarity measure used for scaling the data
            before clustering. Must be "proximity" or "correlation".
        label_encoding: The method used for encoding the labels. Must
            be "None" or "One-Hot".
        chart_id: The id of the file containing the data that k-means
            clustering is run on.
    """
    with open('./data/chart-' + str(chart_id) + ".json", "r") as json_file:
        data = json.load(json_file)
    time_series_data, _, ts_to_labels = clustering.time_series_array(
        data, "one-hot")
    time_series_data = clustering.preprocess(time_series_data, label_encoding,
                                             similarity, ts_to_labels)
    if algorithm == "k-means":
        distances = clustering.tuning_k(time_series_data)
    else:
        distances = clustering.tuning_eps(time_series_data)
    return str(distances)

# runs the flask app
if __name__ == "__main__":
    app.run(debug=True)
